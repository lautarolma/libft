26/9- Strlcpy esta pidiendo warning to overflow in dest. Habra de actualuizarse el control en todos los ft_str


El subject exige que cada funciÃ³n tenga el mismo prototipo y comportamiento que la original de la libc, pero **sÃ­ puedes apoyarte en otras funciones que tÃº mismo ya implementaste**, siempre que no cambies la interfaz pÃºblica.

---

## ğŸ”¹ Estrategia de implementaciÃ³n

### 1. **Empezar por las funciones base (muy simples)**

Estas no dependen de nada mÃ¡s y luego servirÃ¡n de apoyo:

* `ft_isalpha`
* `ft_isdigit`
* `ft_isascii`
* `ft_isprint`
* `ft_strlen`

---

### 2. **Construir funciones compuestas a partir de las anteriores**

* `ft_isalnum` â†’ se puede escribir en base a `ft_isalpha` y `ft_isdigit`:

  ```c
  int ft_isalnum(int c)
  {
      return (ft_isalpha(c) || ft_isdigit(c));
  }
  ```
* `ft_toupper` y `ft_tolower` â†’ usando simples rangos (`'a'..'z'`, `'A'..'Z'`), pero se apoyan en la lÃ³gica de `isalpha`.

---

### 3. **Funciones de memoria y strings fundamentales**

Estas son la base para todo lo que viene despuÃ©s:

* `ft_memset`
* `ft_bzero` â†’ puede implementarse como `ft_memset(ptr, 0, n)`
* `ft_memcpy`
* `ft_memmove` (cuidado, esta no puede basarse en `ft_memcpy` directamente por el solapamiento, pero puedes inspirarte en la lÃ³gica).
* `ft_memchr`
* `ft_memcmp`

Con esto ya tienes una base muy sÃ³lida.

---

### 4. **Funciones de manipulaciÃ³n de strings**

Una vez tengas `ft_strlen` y `ft_memcpy`, puedes simplificar:

* `ft_strlcpy` â†’ usa `ft_strlen` y `ft_memcpy`
* `ft_strlcat` â†’ usa `ft_strlen` y `ft_memcpy`
* `ft_strchr` / `ft_strrchr` â†’ bucles simples sobre `char *`
* `ft_strncmp` â†’ lÃ³gica parecida a `ft_memcmp`
* `ft_strnstr` â†’ se apoya en `ft_strncmp` y `ft_strlen`

---

### 5. **ConversiÃ³n de cadenas**

* `ft_atoi` â†’ bucle con `ft_isdigit` ya hecho
* `ft_calloc` â†’ usa `malloc` + `ft_bzero`
* `ft_strdup` â†’ usa `ft_strlen` + `ft_memcpy`

---

## ğŸ”¹ Bonus (si haces esta parte)

Cuando llegues a listas (`ft_lst*`), muchas funciones se construyen unas sobre otras:

* `ft_lstnew` primero (nodo simple con `malloc`)
* `ft_lstadd_front` / `ft_lstadd_back` â†’ se basan en `ft_lstnew`
* `ft_lstsize` y `ft_lstlast` â†’ recorridos sencillos
* `ft_lstclear` â†’ usa `ft_lstdelone`
* `ft_lstmap` â†’ usa `ft_lstnew`, `ft_lstadd_back`, y `ft_lstclear` para manejo de errores.

---

## ğŸ”¹ Orden sugerido de desarrollo

1. **is/ctype** â†’ `ft_isalpha`, `ft_isdigit`, `ft_isascii`, `ft_isprint`, `ft_isalnum`, `ft_toupper`, `ft_tolower`.
2. **strings bÃ¡sicas** â†’ `ft_strlen`, `ft_strdup`, `ft_strncmp`, `ft_strchr`, `ft_strrchr`.
3. **memoria** â†’ `ft_memset`, `ft_bzero`, `ft_memcpy`, `ft_memmove`, `ft_memchr`, `ft_memcmp`.
4. **funciones combinadas** â†’ `ft_strlcpy`, `ft_strlcat`, `ft_strnstr`.
5. **nÃºmeros y alloc** â†’ `ft_atoi`, `ft_calloc`.
6. (Bonus) â†’ listas.

---

âœ… De esta manera, **maximizas la reutilizaciÃ³n**:

* `ft_isalnum` depende de `isalpha + isdigit`.
* `ft_bzero` depende de `memset`.
* `ft_calloc` depende de `bzero`.
* `ft_strdup` depende de `strlen + memcpy`.
* `ft_strnstr` depende de `strlen + strncmp`.

---

Â¿Quieres que te arme un **mapa visual** (tipo diagrama de dependencias) mostrando quÃ© funciones se pueden construir sobre cuÃ¡les, para que tengas una guÃ­a clara de reutilizaciÃ³n?

