man de las siguientes funciones:

calloc
SYNOPSIS
       #include <stdlib.h>

       void *malloc(size_t size);
       void free(void *ptr);
       void *calloc(size_t nmemb, size_t size);
       void *realloc(void *ptr, size_t size);
DESCRIPTION
       The  malloc()  function allocates size bytes and returns a pointer to the allocated memory.  The memory is not ini‚Äê
       tialized.  If size is 0, then malloc() returns either NULL, or a unique pointer value that can  later  be  success‚Äê
       fully passed to free().

       The  free()  function frees the memory space pointed to by ptr, which must have been returned by a previous call to
       malloc(), calloc(), or realloc().  Otherwise, or if free(ptr) has already been called  before,  undefined  behavior
       occurs.  If ptr is NULL, no operation is performed.

       The  calloc()  function allocates memory for an array of nmemb elements of size bytes each and returns a pointer to
       the allocated memory.  The memory is set to zero.  If nmemb or size is 0, then calloc() returns either NULL,  or  a
       unique  pointer  value  that  can  later be successfully passed to free().  If the multiplication of nmemb and size
       would result in integer overflow, then calloc() returns an error.  By contrast, an integer overflow  would  not  be
       detected  in the following call to malloc(), with the result that an incorrectly sized block of memory would be al‚Äê
       located:

           malloc(nmemb * size);

       The realloc() function changes the size of the memory block pointed to by ptr to size bytes.  The contents will  be
       unchanged in the range from the start of the region up to the minimum of the old and new sizes.  If the new size is
       larger than the old size, the added memory will not be initialized.  If ptr is NULL, then the call is equivalent to
       malloc(size), for all values of size; if size is equal to zero, and ptr is not NULL, then the call is equivalent to
       free(ptr).  Unless ptr is NULL, it must have been returned by an earlier call to malloc(), calloc(), or  realloc().
       If the area pointed to was moved, a free(ptr) is done.

       The  reallocarray() function changes the size of the memory block pointed to by ptr to be large enough for an array
       of nmemb elements, each of which is size bytes.  It is equivalent to the call

               realloc(ptr, nmemb * size);

       However, unlike that realloc() call, reallocarray() fails safely in the case where the multiplication  would  over‚Äê
       flow.  If such an overflow occurs, reallocarray() returns NULL, sets errno to ENOMEM, and leaves the original block
       of memory unchanged.

RETURN VALUE
       The malloc() and calloc() functions return a pointer to the allocated memory, which is  suitably  aligned  for  any
       built-in  type.  On error, these functions return NULL.  NULL may also be returned by a successful call to malloc()
       with a size of zero, or by a successful call to calloc() with nmemb or size equal to zero.

       The free() function returns no value.

       The realloc() function returns a pointer to the newly allocated memory, which is suitably aligned for any  built-in
       type,  or  NULL if the request failed.  The returned pointer may be the same as ptr if the allocation was not moved
       (e.g., there was room to expand the allocation in-place), or different from ptr if the allocation was  moved  to  a
       new address.  If size was equal to 0, either NULL or a pointer suitable to be passed to free() is returned.  If re‚Äê
       alloc() fails, the original block is left untouched; it is not freed or moved.

       On success, the reallocarray() function returns a pointer to the newly allocated memory.  On  failure,  it  returns
       NULL and the original block of memory is left untouched.


strdup

SYNOPSIS
       #include <string.h>

       char *strdup(const char *s);

       char *strndup(const char *s, size_t n);
       char *strdupa(const char *s);
       char *strndupa(const char *s, size_t n);

DESCRIPTION
       The  strdup()  function returns a pointer to a new string which is a duplicate of the string s.  Memory for the new
       string is obtained with malloc(3), and can be freed with free(3).

       The strndup() function is similar, but copies at most n bytes.  If s is longer than n, only n bytes are copied, and
       a terminating null byte ('\0') is added.

       strdupa() and strndupa() are similar, but use alloca(3) to allocate the buffer.  They are available only when using
       the GNU GCC suite, and suffer from the same limitations described in alloca(3).

RETURN VALUE
       On success, the strdup() function returns a pointer to the duplicated string.  It returns NULL if insufficient mem‚Äê
       ory was available, with errno set to indicate the cause of the error.

ERRORS
       ENOMEM Insufficient memory available to allocate duplicate string.




________________________________________________________________________________________________
_________________________________________________________________________________________________

PENDIENTES PRE ENTREGA.

- Controlar nombres y prototipos
- Controlar Libft.h y Man (Testear)
- Controlar librerias incluidas al libft.h (permisibilidad del Subject)
- modificar el man e incluir todos los comandos BONUS objs Bonus, etc.

El subject exige que cada funci√≥n tenga el mismo prototipo y comportamiento que la original de la libc, pero **s√≠ puedes apoyarte en otras funciones que t√∫ mismo ya implementaste**, siempre que no cambies la interfaz p√∫blica.

---

## üîπ Estrategia de implementaci√≥n

### 1. **Empezar por las funciones base (muy simples)**

Estas no dependen de nada m√°s y luego servir√°n de apoyo:

* `ft_isalpha`
* `ft_isdigit`
* `ft_isascii`
* `ft_isprint`
* `ft_strlen`

---

### 2. **Construir funciones compuestas a partir de las anteriores**

* `ft_isalnum` ‚Üí se puede escribir en base a `ft_isalpha` y `ft_isdigit`:

  ```c
  int ft_isalnum(int c)
  {
      return (ft_isalpha(c) || ft_isdigit(c));
  }
  ```
* `ft_toupper` y `ft_tolower` ‚Üí usando simples rangos (`'a'..'z'`, `'A'..'Z'`), pero se apoyan en la l√≥gica de `isalpha`.

---

### 3. **Funciones de memoria y strings fundamentales**

Estas son la base para todo lo que viene despu√©s:

* `ft_memset`
* `ft_bzero` ‚Üí puede implementarse como `ft_memset(ptr, 0, n)`
* `ft_memcpy`
* `ft_memmove` (cuidado, esta no puede basarse en `ft_memcpy` directamente por el solapamiento, pero puedes inspirarte en la l√≥gica).
* `ft_memchr`
* `ft_memcmp`

Con esto ya tienes una base muy s√≥lida.

---

### 4. **Funciones de manipulaci√≥n de strings**

Una vez tengas `ft_strlen` y `ft_memcpy`, puedes simplificar:

* `ft_strlcpy` ‚Üí usa `ft_strlen` y `ft_memcpy`
* `ft_strlcat` ‚Üí usa `ft_strlen` y `ft_memcpy`
* `ft_strchr` / `ft_strrchr` ‚Üí bucles simples sobre `char *`
* `ft_strncmp` ‚Üí l√≥gica parecida a `ft_memcmp`
* `ft_strnstr` ‚Üí se apoya en `ft_strncmp` y `ft_strlen`

---

### 5. **Conversi√≥n de cadenas**

* `ft_atoi` ‚Üí bucle con `ft_isdigit` ya hecho
* `ft_calloc` ‚Üí usa `malloc` + `ft_bzero`
* `ft_strdup` ‚Üí usa `ft_strlen` + `ft_memcpy`

---

## üîπ Bonus (si haces esta parte)

Cuando llegues a listas (`ft_lst*`), muchas funciones se construyen unas sobre otras:

* `ft_lstnew` primero (nodo simple con `malloc`)
* `ft_lstadd_front` / `ft_lstadd_back` ‚Üí se basan en `ft_lstnew`
* `ft_lstsize` y `ft_lstlast` ‚Üí recorridos sencillos
* `ft_lstclear` ‚Üí usa `ft_lstdelone`
* `ft_lstmap` ‚Üí usa `ft_lstnew`, `ft_lstadd_back`, y `ft_lstclear` para manejo de errores.

---

## üîπ Orden sugerido de desarrollo

1. **is/ctype** ‚Üí `ft_isalpha`, `ft_isdigit`, `ft_isascii`, `ft_isprint`, `ft_isalnum`, `ft_toupper`, `ft_tolower`.
2. **strings b√°sicas** ‚Üí `ft_strlen`, `ft_strdup`, `ft_strncmp`, `ft_strchr`, `ft_strrchr`.
3. **memoria** ‚Üí `ft_memset`, `ft_bzero`, `ft_memcpy`, `ft_memmove`, `ft_memchr`, `ft_memcmp`.
4. **funciones combinadas** ‚Üí `ft_strlcpy`, `ft_strlcat`, `ft_strnstr`.
5. **n√∫meros y alloc** ‚Üí `ft_atoi`, `ft_calloc`.
6. (Bonus) ‚Üí listas.

---

‚úÖ De esta manera, **maximizas la reutilizaci√≥n**:

* `ft_isalnum` depende de `isalpha + isdigit`.
* `ft_bzero` depende de `memset`.
* `ft_calloc` depende de `bzero`.
* `ft_strdup` depende de `strlen + memcpy`.
* `ft_strnstr` depende de `strlen + strncmp`.

---

¬øQuieres que te arme un **mapa visual** (tipo diagrama de dependencias) mostrando qu√© funciones se pueden construir sobre cu√°les, para que tengas una gu√≠a clara de reutilizaci√≥n?

